package main

import (
	"bytes"
	"crypto/aes"
	"crypto/cipher"
	"encoding/base64"
	"errors"
	"fmt"
	"github.com/google/uuid"
	"net/http"
	"time"
)

type HTTPClient struct {
	client  *http.Client
	BaseURL string
	Headers map[string]string
}

func NewHTTPClient(baseURL string) *HTTPClient {
	timeStamp := time.Now().UnixNano() / int64(time.Millisecond)
	comboxKey := fmt.Sprintf("%s|%s|%d", accessKey, uuid.New(), timeStamp)
	signature := aesEncrypt(comboxKey, secretKey, accessKey)
	headers := map[string]string{
		"ContentType": "application/json",
		"Accept":      "application/json",
		"AccessKey":   accessKey,
		"Signature":   signature,
		"Connection":  "close",
	}
	return &HTTPClient{client: &http.Client{}, BaseURL: baseURL, Headers: headers}
}

// SetHeader sets a custom header on the request.
func (c *HTTPClient) setHeader(req *http.Request, key, value string) {
	req.Header.Set(key, value)
}

// DoRequest sends an HTTP request using the specified method, URL, and optional data.
func (c *HTTPClient) DoRequest(method, url string, data []byte) (*http.Response, error) {
	req, err := http.NewRequest(method, url, bytes.NewBuffer(data))
	if err != nil {
		return nil, err
	}
	// Customize request here if needed
	// Example: c.SetHeader(req, "User-Agent", "My Custom User Agent")
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, err
	}

	return resp, nil
}

// 加密算法
func aesEncrypt(data string, key string, iv string) string {
	if len(key) != 16 {
		return errors.New("AES key must be 16 bytes").Error()
	}

	block, err := aes.NewCipher([]byte(key))
	if err != nil {
		return err.Error()
	}
	// Use PKCS5Padding
	paddingSize := aes.BlockSize - (len(data) % aes.BlockSize)
	paddedData := append([]byte(data), bytes.Repeat([]byte{byte(paddingSize)}, paddingSize)...)

	ciphertext := make([]byte, len(paddedData))

	mode := cipher.NewCBCEncrypter(block, []byte(iv))
	mode.CryptBlocks(ciphertext, paddedData)
	// 进行Base64编码
	encodedString := base64.StdEncoding.EncodeToString(ciphertext)
	return encodedString
}
